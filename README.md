# FlatBuffers + Google Sheets Template

Шаблон для быстрого разворачивания связки **FlatBuffers + Google Sheets** на проекте в Unity.

### Для чего
Связка подходит для средних и крупных проектов, в которых ожидается использование больших объемов статических данных (конфигов),
которые в свою очередь, обычно хранятся в Google таблицах, используют функционал этих таблиц на полную (графики, формулы, кросс-ссылки и т.д.).
Данный шаблон позволяет импортировать данные из Google таблиц и запаковывать конфиги упакованные FlatBuffers банарники. 
Работать с отдельными таблицами, с отдельными листами, или же наоборот со списком листов, изменять внутри уже созданного конфига только часть данных.

### Почему FlatBuffers
**FlatBuffers** - разработанный компанией Google фреймворк, позволяющий максимально исключить десериализацию объектов конфигов (что фактически означает экономию памяти и буст скорости чтения). 
Фреймворк можно использовать и на мелких проектах, но вероятнее всего это окажется нецелесообразным, учитывая громоздкость сетапа.<br>

Сам фреймворк подходит только для статических данных, т.к. читая данные из бинарника, он не создает новые объекты в оперативной памяти, а лиш хранит ссылки и смещения прямо внутри массива байтов, загруженных в память.
Таким образом, путешествуя по дереву ссылок, вытаскиваются конечные примитивные типы данных: числа, строки, булки и т.д. 
Такое можно провернуть лишь при чтении (ведь для записи новых данных в класс, нужен экземпляр этого класса), поэтому фреймворк и подходит лишь для статики. 
Несомненно, весь этот прием для увеличения скорости чтения, экономии оперативной памяти и уменьшения фрагментации памяти при работе с конфигами.<br>

Еще один весомы плюс - гибкость. Компилятор Flatс, который компилирует специальные .fbs схемы в код, с которым может работать фреймворк, может компилировать эти файлы в код на разных языках.
Таким образом, FlatBuffers подходит не только для Unity, но и для других движков, а также для работы сервера.<br>

![image](https://github.com/user-attachments/assets/ceec8272-e7dc-4cb1-b725-f72f2e00b766)

Ну и если очень надо, можно опционально подключить генерацию кода с поддержкой сериализации кода в JSON (Newtonsoft). Но этой частью здесь мы пользоваться не будем.

Подробнее про фреймворк FlatBuffers можно почитать на оффициальном сайте [flatbuffers.dev](https://flatbuffers.dev/).

___

## Подготовка проекта

### 1. Ставим Nuget для Unity
Тут все просто, ставим NuGet для Unity, используя ссылку ниже, или, если угодно, с [офф репозитория скопировать можно](https://github.com/GlitchEnzo/NuGetForUnity):
```
https://github.com/GlitchEnzo/NuGetForUnity.git?path=/src/NuGetForUnity
```

### 2. Ставим FlatBuffers
Через появившееся меню NuGet в Unity заходим в менеджер пакетов NuGet. Путь **NuGet/Manage NuGet Packages**. В поиске вбиваем **Google.Flatbuffers** и устанавливаем пакет.
<br>
![image](https://github.com/user-attachments/assets/3e1fe5aa-2ee3-4fd0-9715-1abcc791b93f)

> [!WARNING]
> В следующем пункте описано добавление компилятора flatc.exe, однако, в данном шаблоне он уже добавлен: **Assets/FlatBuffers/flatc.exe**

В случае, если вы настраиваете проект самостоятельно, то с [официального репозитория FlatBuffers](https://github.com/google/flatbuffers/releases) нужно скачать компилятор flatc для своей операционной системы. Для себя я рассматриваю пример для Windows, если что.
Исполняемый файл flatc.exe можно поместить куда-то на ПК (в этом случае нужно также добавить путь к flatc.exe в параметры окружающей среды, в Path), или же в папку с проектом. В данном шаблоне компилятор располагается внутри папки с проектом: **Assets/FlatBuffers/flatc.exe**.
FlatBuffers готов к использованию в Unity.

### 3. Готовим схемы конфигов
Схемы - это специальные файлы с расширением .fbs, которые помогают скомпилировать структуру данных в код на указанном языке программирования при помощи компилятора flatc. В нашем случае, конечно, это будет C#.
В данном шаблоне приведен пример схем. При чем схем, раскиданных по разным файлам и папкам проекта, чтобы можно было понять, как можно выстраивать структуру конфигов.

> [!IMPORTANT]
> Путь до папки с примерами схем в шаблоне: Assets/FlatBuffersSetup/Scripts/Shared/Schemas

![image](https://github.com/user-attachments/assets/c9aafa14-7860-46e2-9348-e7d2b41f064a)
![image](https://github.com/user-attachments/assets/fb76a04a-4507-4ea4-968f-90512f6784bd)
![image](https://github.com/user-attachments/assets/54b59fb5-12a5-4b6c-b781-15050227c7ed)

**Интересный момент**: на последнем скриншоте с конфигом **RewardsSettings** приведен пример расширения класса наград: переменная ext: RewardExt; может быть двух типов: либо **ResourceReward**, либо **AbilityReward**.
Прошу обратить внимание, как это место потом преобразуется в код. В клуссе **RewardSettings** появятся два поля: **Ext** и **ExtType**. Первое возвращает **object**, а второе enum, в который вписан тип. При помощи этого enum можно понять, как кастануть **object**, который возвращает **Ext**.

> [!TIP]
> Rider и другие IDE имеют плагины для подсветки синтаксиса файлов с расширением .fbs

### 4. Кодогенерация
В проекте есть скрипт, который помогает скомпилировать схемы в код при помощи компилятора flatc.exe. Путь к скрипту: **Asset/FlatBuffers/Editor/FlatcCompiler.cs**. 
В нем есть три самые главные штуки, которые надо знать:
1. Приватная константа **FLATC_PATH** - путь до исполняемого файла компилятора flatc.exe. Напоминаю, что в этом проекте-шаблоне этот путь: **Assets/FlatBuffers/flatc.exe**
2. Публичный метод Compile(string schemaPath, string outputDirectory) - генерирует код в указанную папку из указанной схемы
3. Публичный метод Compile(IEnumerable<string> schemaPaths, string ouputDirectory) - генерирует код в указанную папку из указанного списка схем
   
![image](https://github.com/user-attachments/assets/09c50655-2653-4537-ba8d-f42884706e1a)

В качестве примера использования этого класса и компиляции схем в код в принципе, существует класс **Assets/FlatBuffersSetup/Scripts/FlatBuffers/Editor/FlatBUffersMenu.cs**.
В этом классе создается кнопка в главном меню Unity: **FlatBuffers/Compile FlatBuffers Schemas**. Здесь же указаны пути к файлам, которые нужно скомпилировать и куда нужно скомпилировать:

![image](https://github.com/user-attachments/assets/fe98e841-ee42-4332-b60d-22aab45a2dfa)
<br><br>
После прожажтия **FlatBuffers/Compile FlatBuffers Schemas**, и успешных логов, вы увидите сгенерированные файлы классов по указанному пути.

![image](https://github.com/user-attachments/assets/1cf86ba4-7fb6-4d48-b812-cf5502301034)

### 5. Импорт таблиц из гугла
Для того, чтобы правильно настроить возможность скачивать данные из гугл таблиц используя сервисный аккаунт, рекомендую посмотреть половину [видео из Лавки Разработчика](https://www.youtube.com/watch?v=x0lg8--NGB0).
Подробно здесь мы останавливаться не будем, но следует отметить, что в данном проекте - шаблоне, все необходимые действия уже проделаны, однако, ПРИВАТНЫЙ ФАЙЛ КЛЮЧА ОТСУТСТВУЕТ, поэтому импорт из [тестовой таблицы](https://docs.google.com/spreadsheets/d/1QTHf1kjmtgjxKWRqXZ5MsKCOBzUJbiQTc0yOcWT2dEQ/edit?usp=sharing) работать не будет. Приватный ключ качается по инструкции из видео, ссылку на которое я привел выше. Т.к. таблица с примером в открытом доступе, то ваш приватный ключ сработает для успешного импорта таблицы.

В проекте есть класс-помощник для импорта таблиц из гугла - **GoogleSheetsImporter**. В его конструктор нужно передавать **spreadsheetId**, и использовать один ищ методов инициализации импортера: **WithCredentials(string credentialsPath)** или **WithApiKey(string apiKey)**. Первый вариант для способа с приватным ключем от сервисного аккаунта, созданного по инструкции из видео. Второй вариант только для публичных таблиц, просто приватный токен для доступа к данным без авторизации. Это так, опционально, он все равно делается буквально в том же месте, где и сервисный аккаунт создается. Если интересно, погуглите.

В дальнейшем экземпляр класса можно использовать с асинхронным методом **DownloadAndParseSheet(string sheetName)** - то есть загрузить лист из таблицы и распарсить. На этом месте мы остановимся. Класс **GoogleSheetsImporter** абстрактный. Это сделано для того, чтобы заставить вас реализовать метод **ParseCell(string header, string cellData)** - для парсинга каждой непустой ячейки таблицы. Знаем заголовок, знаем данные ячейки - можем делать с этим, что хотим.

### 6. Парсинг таблиц и сохранение в бинарник при помощи FlarBuffers
В данном проекте-шаблоне есть целый набор скриптов, которые помогают понять как удобно использовать связку FlatBuffers + Google Sheets и просто взять за основу данный подход, изменить его или дополнить. Скрипты находятся в папке **Assets/FlatBuffersSetup/SettingsImport/**. Рассмотрим ключевые из них:

#### 6.1 ImportConstants
Здесь хранятся все константы, нужные для работы связки. В большинстве случаев связка настраивается на проекте единожды, и удобно хранить данные об Id таблицы, путях до папок и файлов в проекте в одном месте. 
![image](https://github.com/user-attachments/assets/128f850d-03bf-432c-af9e-aa36fd2fb9e0)

#### 6.2 ProjectImporter
Этот класс расширяет класс **GoogleSheetsImporter**, но также остается абстрактным. Он уже в себе содержит ссылку на GameSettingsT - класс, сгенерированный при помощи схемы .fbs. Используйте этот скрипт как шаблон и вставляйте свои типы из своего проекте. Класс делается абстрактным для того, чтобы уменьшить количество бойлерплейта в скриптах конкретных импортерах. В конструктор кроме spreadsheetId, добавляется **sheetName** (имя листа в табличке), т.к. каждый скрипт импортера подразумевает импорт с определенного листа таблицы. Также добавляются методы SaveToFile()  и LoadFromFile().

Принцип работы импортера листа следующий:
1. Создается локальный экземпляр рутового класса настроей. В случае шаблона это GameSettingsT. Данный экземпляр будет хранить лишь информацию о данных с одного листа таблицы, остальные данные будут по нулям.
   
> [!NOTE]
> Сгенерированные файлы, помеченные T на конце, указывают на то, что это классические классы, которые поддаются изменениям. Нам нужен этот вариант классов только для импорта, в рантайме они использоваться не будут и не должны.

2. Данные парсятся из таблицы и заполняют часть этого локального конфига
3. Экземпляр с данными будет сохраняться как локальный файл конфига конкретного листа таблицы. То есть не смотря на то, что храниться будет корневой GameSettings, но данные будут заполнены только одного листа. Это нужно, чтобы оставалась возможность импортировать листы по отдельности, но в конце сохранять в единый файл конфига, в который попадают данные из многих листов таблицы. Для сохранения используется метод SaveToFile()
4. Для случаев, когда мы импортируем данные из одного листа, а в настройках уже есть данные с других листов, нам нужно будет загрузить все локальные настройки с каждого листа и обновить лишь те, которые импортируются в данный момент. Поэтому уже существующие локальные настройки должны быть загружены, это делается при помощи метода LoadFromFile(). Далее станет понетнее, как работает.

![image](https://github.com/user-attachments/assets/739d338a-0267-4458-b3b6-94c3f7fae437)

#### 6.3 IImporter
Чтобы добраться наконец до конкретных импортеров, нам нужно взглянуть еще на такой интерфейс как IImporter, который закладывает API для работы уже просмотренного ProjectImporter, но добавляет метод  **AddToSettings(GameSettingsT gameSettingsT)**.
Этот метот нужен как раз для ситуации, описанной в п.4 выше. То есть у нас в при импорте одного листа из N шт. Происходит следующее:
1. Создается GameSettingsT, который заполнен ТОЛЬКО данными из определенного листа таблицы.
2. Система должна загрузить уже сохраненные прежде GameSettingsT, содержащие данные из других листов таблиц, но исключить тот, что мы только что импортировали
3. Создать новый файл GameSettingsT, который будет содержать все уже существующие данные и обновленные данные из одной таблицы. Этот созданный GameSettingsT пускается по кругу всех импортеров и они кладут в него по кусочку данных: кто-то старые, загруженные с диска, кто-то новые, импортированные из листа гугл таблицы

#### 6.4 ChestsImporter и BuildingsImporter
Это уже конкретные импортеры конкретных листов таблиц. Именно подобные экземпляры вам нужно будет создавать, чтобы добавлять функционал импорта из таблицы. Каждый лист - новый подобный импортер. Можно увидеть, как внутри зашита ссылка на конкретную таблицу, на конкретный лист.

![image](https://github.com/user-attachments/assets/fd5e50c4-bad1-4413-831c-72a015930e97)

Также нужно определить, какую часть рутового конфига будет импортировать этот импортер. В примере с BuildingsImporter, это лист Buildings. Его нужно создать, чтобы потом в него ложить данные.

![image](https://github.com/user-attachments/assets/86b29f94-6e01-49fe-ae86-ab7e221e5037)

Метод **AddToSettings(GameSettingsT gameSettingsT)** тут тоже раскрывается. Видно, как заменяется одна конкретная часть конфига. 

Ну и еще одна часть - то как парсится каждая непустая ячейка в методе **ParseCell(string header, string cellData)**. Вы можете делать что угодно со полученными данными. Однако, рекомендую ознакомиться с файлом ChestsImporter.cs, чтобы ознакомиться с тем, как импортируются те самые расширяемые при помощи Ext схемы, описанные еще в пункте 3 настоящей инструкции.
![image](https://github.com/user-attachments/assets/023e0e25-2d67-455d-b8fb-6923ee03e9e8)

> [!IMPORTANT]
> Можно смело копировать файлы к себе и подставлять свои экземпляры классов конфигов и адаптировать их, ну и расширять количество импортеров, конечно. Конкретно эти скрипты подходят для большинства проектов (если применить к ним конкретные конфиги из своего проекта).

### 7. ImportingMenu и SettingsImportUtils
Ну и последнее. Нужно завернуть всё написанное выше в красивую кнопочку в главном меню Unity. Для этого приведен пример с классом **ImportingMenu**. Где приведены примеры импорта конфигов отдельных листов по-одному: Chests и Buildings. Также есть пример импорта "всех листов" и отдельного списка листов, то есть не все, но и не один.

![image](https://github.com/user-attachments/assets/acd8b965-bd07-485e-aab9-7ccc68e1f1eb)


Все методы ссылаются на SettingsImportUtils, которы тоже важен для проекта. Там помимо вспомогательных методов  ImportAllConfigs(), ImportConfig() и ImportConfigs(), есть важный метод GetAllImporters(), который возвращает список всех испортеров, чтобы конечный конфиг сформировался правильно. Можно запариться и сделать через рефлексию и не думать о том, что при добавлении нового импортера, его нужно прокинуть и здесь. Это я оставлю на ваше усмотрение. 

![image](https://github.com/user-attachments/assets/677dfa32-eb12-4a3e-9d41-e8c55985f578)

### 8. SettingsProvider
Это класс с примером использования в рантайме. Здесь из файла с загружается массив байт, с которым и работает внутренний вариант класса GameSettings (тот, что без T).

![image](https://github.com/user-attachments/assets/0ff2d420-2e72-4172-bcc4-c45b3d6ea27d)


## Итог
После проведенной работы мы имеем следующее:
1. Связку FlatBuffers + Google Sheets. То есть можно работать с конфигами в гугл таблицах и импортировать данные в проект парой кликов. При этом, пользоваться оптимизированными FlatBuffers и радоваться
2. После предварительной настройки импорта, расширение импортеров предполагает создание 1 класса для каждой страницы + дописки в метод GetAllImporters() этого нового класса.







